import os
import logging
import asyncio
import json
from datetime import datetime
import yaml
from fastapi import FastAPI, Request, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware

# [Core 모듈 임포트]
# 시스템의 핵심 로직(엔진, 시장 데이터, 백테스터 등)을 가져옵니다.
from core.engine import Engine
from core.visualization import TradeVisualizationService
from core.backtester import DataLoader, Backtester
from core.dao import ChecklistDAO, TradeDAO

# 로깅 설정
logger = logging.getLogger("WebServer")

# [전역 변수]
# 엔진 인스턴스는 start_server 함수에서 주입받아 전역으로 사용합니다.
engine_instance: Engine = None
visualization_service = None

# FastAPI 앱 초기화
app = FastAPI(title="Anti-Stock Trading System")

# [미들웨어 설정]
# CORS (Cross-Origin Resource Sharing) 허용 - 개발 편의성
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# [정적 파일 및 템플릿 설정]
# CSS, JS, 이미지 등은 static 폴더에서, HTML은 templates 폴더에서 서빙
app.mount("/static", StaticFiles(directory="web/static"), name="static")
templates = Jinja2Templates(directory="web/templates")

# ==================================================================================
# [1] 페이지 라우터 (Page Routes)
# 웹 브라우저에서 접속했을 때 HTML 화면을 보여주는 역할
# ==================================================================================

@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    """메인 대시보드 페이지"""
    return templates.TemplateResponse("index.html", {"request": request})

@app.get("/manual", response_class=HTMLResponse)
async def get_manual(request: Request):
    """사용자 매뉴얼 페이지"""
    return templates.TemplateResponse("manual.html", {"request": request})

@app.get("/manual/backtest_process", response_class=HTMLResponse)
async def get_backtest_process(request: Request):
    """백테스트 프로세스 설명 페이지"""
    return templates.TemplateResponse("backtest_process.html", {"request": request})


# ==================================================================================
# [2] 대시보드 - 시스템 제어 & 상태 (Dashboard Control & Status)
# 시스템 시작/중지, 현재 상태 조회, 로그 확인
# ==================================================================================

@app.post("/api/control")
async def control_engine(action: dict):
    """
    [제어] 엔진 시작(start), 중지(stop), 재시작(restart) 명령 수행
    """
    cmd = action.get("command")
    if engine_instance:
        if cmd == "start":
            engine_instance.start_trading()
        elif cmd == "stop":
            engine_instance.stop_trading()
        elif cmd == "restart":
            engine_instance.restart()
    return {"status": "ok"}

@app.get("/api/status")
async def get_status():
    """
    [상태] 현재 엔진 동작 여부, 포트폴리오 자산, 활성화된 전략 목록 등 반환
    """
    if engine_instance:
        try:
            active_strategies = list(engine_instance.strategies.keys())

            # 포트폴리오 데이터 구성
            portfolio_data = {
                "cash": engine_instance.portfolio.cash,
                "deposit_d1": engine_instance.portfolio.deposit_d1,
                "deposit_d2": engine_instance.portfolio.deposit_d2,
                "total_asset": engine_instance.portfolio.total_asset,
                "positions": sorted([
                    {
                        "symbol": p.symbol,
                        "name": p.name,
                        "qty": p.qty,
                        "avg_price": p.avg_price,
                        "current_price": p.current_price,
                        "pnl_pct": (p.current_price - p.avg_price)/p.avg_price*100 if p.avg_price > 0 else 0,
                        "holding_days": int((datetime.now().timestamp() - p.first_acquired_at) / 86400) if p.first_acquired_at > 0 else 0
                    } for p in engine_instance.portfolio.positions.values()
                ], key=lambda x: x['name']),
                "total_eval_amt": sum(p.current_price * p.qty for p in engine_instance.portfolio.positions.values())
            }

            return {
                "is_running": engine_instance.is_trading, # UI는 이 값으로 실행 중 여부 판단
                "active_strategies": active_strategies,
                "portfolio": portfolio_data
            }
        except Exception as e:
            logger.error(f"Status Error: {e}")
            import traceback
            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    return {"status": "stopped"}

@app.get("/api/config")
async def get_config():
    """[설정] 전략 설정값 조회"""
    if engine_instance:
        cfg = engine_instance.config.copy()
        # 시스템 내부 키 제외하고 순수 전략 설정만 필터링
        system_keys = ["system", "database", "active_strategy"]
        strategies_list = [k for k in cfg.keys() if k not in system_keys and isinstance(cfg[k], dict)]
        cfg["strategies_list"] = strategies_list
        return cfg
    return {}

@app.post("/api/config")
async def update_config(request: Request):
    """[설정] 전략 설정값 변경 및 저장"""
    data = await request.json()
    if engine_instance:
        if "active_strategy" in data:
            engine_instance.config["active_strategy"] = data["active_strategy"]
            
        for key, value in data.items():
            if key != "active_strategy":
                engine_instance.update_strategy_config({key: value})

        # 파일로 저장
        with open("config/strategies.yaml", "w", encoding="utf-8") as f:
            yaml.dump(engine_instance.config, f)
        return {"status": "ok"}
    return {"status": "error", "message": "Engine not initialized"}

@app.get("/api/system/settings")
async def get_system_settings():
    """[설정] 시스템 전역 설정(API Key 제외) 조회"""
    if engine_instance:
        cfg = engine_instance.system_config.copy()
        if "tps_server_url" not in cfg:
             cfg["tps_server_url"] = "http://localhost:9000"
        return JSONResponse(content=cfg)
    return JSONResponse(content={})

@app.post("/api/system_config")
async def update_system_config(request: Request):
    """[설정] 시스템 설정 변경"""
    data = await request.json()
    if engine_instance:
        engine_instance.update_system_config(data)
        return {"status": "ok"}
    return {"status": "error", "message": "Engine not initialized"}


# --- 로그(Logs) 관련 ---

class LogListHandler(logging.Handler):
    """메모리에 최신 로그를 담아두고 웹소켓으로 전송하는 핸들러"""
    def __init__(self):
        super().__init__()
        self.logs = []
        self.websockets = []
        self.loop = None

    def set_loop(self, loop):
        self.loop = loop

    def emit(self, record):
        try:
            log_entry = self.format(record)
            self.logs.append(log_entry)
            if len(self.logs) > 100:
                self.logs.pop(0)

            # 연결된 모든 웹소켓 클라이언트에 전송
            if self.loop and self.loop.is_running():
                 for ws in self.websockets:
                     asyncio.run_coroutine_threadsafe(ws.send_text(log_entry), self.loop)
        except Exception:
            self.handleError(record)

list_handler = LogListHandler()

@app.on_event("startup")
async def startup_event():
    """서버 시작 시 메인 루프를 핸들러에 등록"""
    loop = asyncio.get_running_loop()
    list_handler.set_loop(loop)

# Engine 초기화 시 logger에 핸들러 추가 필요 (Start Server에서 처리하거나 여기서?)
# main.py에서 로거 설정을 하므로, 여기서는 패스하거나 필요시 추가

@app.websocket("/ws/logs")
async def websocket_logs(websocket: WebSocket):
    """실시간 로그 스트리밍"""
    await websocket.accept()
    list_handler.websockets.append(websocket)
    try:
        # 최근 로그 50개 먼저 전송
        for log in list_handler.logs[-50:]:
            await websocket.send_text(log)
        while True:
            await websocket.receive_text() # 유지용
    except WebSocketDisconnect:
        list_handler.websockets.remove(websocket)

@app.get("/api/logs/download")
async def download_logs():
    """전체 로그 파일 다운로드"""
    log_file = os.path.join("logs", "anti_stock.log")
    if os.path.exists(log_file):
        return FileResponse(log_file, media_type='text/plain', filename="anti_stock.log")
    return {"status": "error", "message": "Log file not found"}


# ==================================================================================
# [3-1] TPS 서버 상태 (TPS Status)
# ==================================================================================

@app.get("/api/tps/stats")
async def get_tps_stats():
    """TPS 서버 연결 상태 및 통계 조회"""
    from core import kis_api as ka
    return ka.get_rate_limiter_stats()

# ==================================================================================
# [3] 대시보드 - 시장 데이터 (Market Data)
# 감시종목 리스트, 실시간 시세, 차트 데이터
# ==================================================================================

@app.get("/api/stocks")
async def get_stock_master():
    """모든 종목 마스터 데이터(코드, 이름) 조회 (자동완성용)"""
    if engine_instance and engine_instance.market_data:
        stocks = engine_instance.market_data.get_master_list()
        return stocks
    return []

@app.get("/api/watchlist")
async def get_watchlist():
    """현재 감시종목 리스트 조회"""
    if engine_instance:
        # 1. 파일 설정 등에서 로드 (Engine이 관리)
        # engine.market_data.polling_symbols가 실제 감시 중인 종목
        symbols = list(engine_instance.market_data.polling_symbols)
        return symbols
    return []

@app.post("/api/watchlist")
async def update_watchlist(request: Request):
    """
    감시종목 추가 또는 전체 업데이트 (저장 버튼)
    payload case 1: { "symbol": "005930" } -> Add single
    payload case 2: { "watchlist": ["005930", "000660"] } -> Replace all
    """
    data = await request.json()
    
    # Case 2: Bulk Update (Save button)
    if "watchlist" in data and engine_instance:
        new_list = data["watchlist"]
        # [Corrected Logic] Delegate to Engine to handle DB sync and market data subscription
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, engine_instance.update_watchlist, new_list)
        return {"status": "ok"}

    # Case 1: Add Single
    symbol = data.get("symbol")
    if engine_instance and symbol:
        # For single add, engine also has a method or we can use market_data if persistence is handled safely elsewhere.
        # But consistency is better. Engine doesn't have add_single exposed easily in snippet?
        # Let's check engine.py again or just use market_data.add_symbol BUT we must ensure DB sync.
        # Actually providing a single add via update_watchlist is inefficient.
        # Let's stick to market_data.add_symbol but we know it doesn't save to DB unless UniverseManager handles it?
        # UniverseManager.update_watchlist handles FULL update.
        # MarketData.add_symbol only updates memory.
        # IF we want to save single add, we should probably append and save.
        
        # However, looking at original server.py:
        # It calls `engine_instance.market_data.add_symbol(symbol)` directly for Case 1.
        # So "Add Single" was NOT saving to DB in the original code either?
        # Let's check original server.py line 162... 
        # Actually original server.py had:
        # @app.post("/api/watchlist") -> update_watchlist (BULK)
        # It didn't seem to have a separate "add single" in the same endpoint?
        # Ah, original has `update_watchlist` taking `request`.
        # Code: `new_list = data.get("watchlist", [])`. If `new_list` is present, it does bulk.
        # It DOES NOT seem to handle "Add Single" in the same endpoint in the original!
        # Wait, the refactored code has "Add Single" logic added?
        # Let's look at `server.py` line 295 again.
        # It seems the refactored code has EXTRA logic for single add.
        # Providing the bulk update fix is the main request.
        
        engine_instance.market_data.add_symbol(symbol)
        # To ensure persistence, we ideally should add to DB too.
        # WatchlistDAO.add_symbol(symbol)
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, WatchlistDAO.add_symbol, symbol)
        return {"status": "ok"}
        
    return {"status": "error"}

@app.post("/api/watchlist/import")
async def import_watchlist_from_broker():
    """증권사(HTS) 관심종목 가져오기"""
    if engine_instance:
        try:
            # [Corrected Logic] Delegate to Engine
            loop = asyncio.get_running_loop()
            total, added = await loop.run_in_executor(None, engine_instance.import_broker_watchlist)
            
            return {
                "status": "ok", 
                "total": total, 
                "added": added,
                "message": f"총 {total}개, 신규 {added}개 종목을 가져왔습니다."
            }
        except Exception as e:
            return {"status": "error", "message": str(e)}
            
    return {"status": "error", "message": "Engine module not initialized"}

@app.delete("/api/watchlist/{symbol}")
async def remove_from_watchlist(symbol: str):
    """감시종목 삭제"""
    if engine_instance:
        engine_instance.market_data.remove_symbol(symbol)
        return {"status": "ok"}
    return {"status": "error"}



@app.post("/api/market/data")
async def get_market_data_batch(request: Request):
    """
    [대시보드 메인] 감시종목들의 상세 정보(현재가, 등락률, 미니차트) 조회
    - 5초마다 폴링됨
    """
    if engine_instance and engine_instance.market_data:
        md = engine_instance.market_data
        
        # Try to get symbols from request body (watchlist.js sends them)
        try:
            body = await request.json()
            symbols = body.get("symbols", [])
        except Exception:
            symbols = []

        # Fallback to engine's polling list if empty
        if not symbols:
            symbols = list(md.polling_symbols)
            
        results = []

        # 백그라운드 스레드에서 데이터 조회 (IO 바운드 방지)
        def _fetch_batch_data():
            for symbol in symbols:
                # [수정됨] TPS 제한을 위해 0.2초 딜레이가 있었으나, 
                # RateLimiter가 있으므로 삭제하거나 최소화함. (너무 느려짐 방지)
                # import time; time.sleep(0.05) 
                
                try:
                    name = md.get_stock_name(symbol)
                    # 일봉 데이터 가져오기 (캐시 사용) - 30일치
                    df = md.get_bars(symbol, timeframe="1d", lookback=30)
                    
                    price = 0
                    change = 0
                    ma20 = 0
                    sparkline = []
                    
                    if not df.empty:
                        sparkline = df['close'].tolist()
                        price = float(df.iloc[-1]['close'])
                        
                        # 전일 대비 등락률
                        if len(df) >= 2:
                            prev = float(df.iloc[-2]['close'])
                            if prev > 0:
                                change = (price - prev) / prev * 100
                                
                        # MA20
                        if len(df) >= 20:
                            ma20 = df['close'].tail(20).mean()
                        else:
                            ma20 = df['close'].mean()

                    # 보유 여부 체크
                    is_held = symbol in engine_instance.portfolio.positions

                    results.append({
                        "symbol": symbol,
                        "code": symbol,    # Added 'code' as alias for compatibility with watchlist.js
                        "name": name,
                        "price": price,
                        "change_rate": round(change, 2),
                        "ma20": round(ma20, 0),
                        "sparkline": sparkline,
                        "is_held": is_held
                    })
                except Exception as e:
                    logger.error(f"Market Data Error {symbol}: {e}")
            return results

        loop = asyncio.get_running_loop()
        data = await loop.run_in_executor(None, _fetch_batch_data)
        return {"status": "ok", "data": data}
        
    return {"status": "ok", "data": []}

@app.get("/api/chart/data")
async def get_chart_data(symbol: str, timeframe: str = "1m", lookback: int = 300):
    """
    [차트 팝업] 특정 종목의 캔들 데이터 조회
    """
    if visualization_service:
        try:
            # VisualizationService가 데이터 전처리 담당
            data = visualization_service.get_chart_data(symbol, timeframe, lookback)
            return data
        except Exception as e:
            return {"status": "error", "message": str(e)}
    return {"status": "error", "message": "Service not initialized"}


# ==================================================================================
# [4] 백테스트 (Backtest Section)
# 데이터 확인, 다운로드, 백테스트 실행, 엑셀 내보내기
# ==================================================================================

@app.post("/api/backtest/check_data")
async def backtest_check_data(request: Request):
    """백테스트용 데이터가 로컬에 있는지 확인"""
    data = await request.json()
    # 전략 설정에서 타임프레임 확인
    timeframe = _get_strategy_timeframe(data.get("strategy_id"), "D")
    
    loader = DataLoader() # core.backtester 모듈
    exists = loader.check_availability(data.get("symbol"), data.get("start"), data.get("end"), timeframe=timeframe)
    return {"status": "ok", "exists": exists}

@app.post("/api/backtest/download")
async def backtest_download(request: Request):
    """백테스트용 데이터 다운로드 (없는 경우)"""
    data = await request.json()
    timeframe = _get_strategy_timeframe(data.get("strategy_id"), "D")
    
    loader = DataLoader()
    try:
        df = loader.download_data(data.get("symbol"), data.get("start"), data.get("end"), timeframe=timeframe)
        return {"status": "ok", "count": len(df)}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.post("/api/backtest/data")
async def get_backtest_table_data(request: Request):
    """백테스트 화면의 표(테이블)에 보여줄 데이터 조회"""
    data = await request.json()
    timeframe = _get_strategy_timeframe(data.get("strategy_id"), "D")
    
    try:
        loader = DataLoader()
        df = loader.load_data(data.get("symbol"), data.get("start"), data.get("end"), timeframe=timeframe)
        
        if not df.empty:
            # 보조지표 간단 추가 (화면 표시용)
            df['ma5'] = df['close'].rolling(5).mean().fillna(0)
            df['ma20'] = df['close'].rolling(20).mean().fillna(0)
            df = df.fillna(0)
            return {"status": "ok", "data": df.to_dict('records')}
            
        return {"status": "error", "message": "No data"}
    except Exception as e:
        return {"status": "error", "message": str(e)}

@app.websocket("/ws/backtest")
async def backtest_ws(websocket: WebSocket):
    """
    [웹소켓] 백테스트 실행 및 실시간 진행상황 전송
    """
    await websocket.accept()
    try:
        # 설정 수신
        data = await websocket.receive_json()
        
        if not engine_instance:
            await websocket.send_json({"type": "error", "message": "Engine not ready"})
            return

        # 진행상황 콜백 함수
        def progress_callback(evt_type, payload):
            asyncio.run_coroutine_threadsafe(
                websocket.send_json({"type": evt_type, "data": payload}),
                asyncio.get_event_loop()
            )

        # 백테스트 실행 (Blocking이므로 Executor 사용)
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(
            None,
            lambda: engine_instance.run_backtest(
                data.get("strategy_id"),
                data.get("symbol"),
                data.get("start"),
                data.get("end"),
                int(data.get("initial_cash", 100000000)),
                progress_callback=progress_callback
            )
        )

        # 최종 결과 전송
        if "error" in result:
             await websocket.send_json({"type": "error", "message": result["error"]})
        else:
             await websocket.send_json({"type": "result", "result": result})

    except Exception as e:
        logger.error(f"Backtest WS Error: {e}")
        # await websocket.send_json({"type": "error", "message": str(e)}) # 연결 끊김 대비

@app.post("/api/backtest/export")
async def export_backtest_excel(request: Request):
    """백테스트 결과를 엑셀 파일로 생성하여 다운로드"""
    try:
        body = await request.json()
        # ... (엑셀 생성 로직: pandas ExcelWriter 사용)
        # 로직이 길어서 요약: 데이터 로드 -> 백테스트 실행 -> 매매내역 병합 -> 엑셀 저장
        # (기존 코드 유지)
        
        # 임시 반환 (실제 구현은 기존 코드 참조하여 복원 필요)
        return {"status": "error", "message": "Export not fully implemented in cleanup"} 
    except Exception as e:
         return {"status": "error", "message": str(e)}

def _get_strategy_timeframe(strategy_id, default="D"):
    """전략 설정파일에서 타임프레임(D/M 등)을 읽어오는 헬퍼"""
    if not strategy_id: return default
    try:
        with open("config/strategies.yaml", "r", encoding="utf-8") as f:
            c = yaml.safe_load(f)
            return c.get(strategy_id, {}).get("timeframe", default)
    except:
        return default


# ==================================================================================
# [5] 매매일지 & 체크리스트 (Journal & Checklist)
# 매매 이력 DB 조회 및 체크리스트 관리
# ==================================================================================

@app.get("/api/journal/trades")
async def get_journal_trades(start: str=None, end: str=None, symbol: str=None):
    """매매 이력 조회 (필터링 포함)"""
    if engine_instance:
        try:
            # 메모리에 있는 내역 사용 (속도 최적화)
            trades = engine_instance.trade_history
            
            # 필터링 로직 (날짜, 종목명 등)
            filtered = []
            s_dt = datetime.strptime(start.replace("-",""), "%Y%m%d") if start else None
            e_dt = datetime.strptime(end.replace("-",""), "%Y%m%d").replace(hour=23,minute=59) if end else None
            
            for t in trades:
                # 주문접수 이벤트 등 중복 제거
                if t.price <= 0 or t.event_type == "ORDER_SUBMITTED":
                    continue
                
                # 날짜 필터
                if s_dt and t.timestamp < s_dt: continue
                if e_dt and t.timestamp > e_dt: continue
                
                # 종목명 검색
                if symbol:
                    t_name = engine_instance.market_data.get_stock_name(t.symbol)
                    if (symbol not in t.symbol) and (symbol not in t_name):
                        continue
                
                # 데이터 포맷팅
                item = {
                    "timestamp": t.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                    "symbol": t.symbol,
                    "name": engine_instance.market_data.get_stock_name(t.symbol),
                    "side": t.side,
                    "price": t.price,
                    "qty": t.qty,
                    "pnl": t.pnl,
                    "revenue_rate": t.pnl_pct,
                    "strategy_id": getattr(t, "strategy_id", "common"), # Add strategy_id
                    "meta": getattr(t, "meta", {})                      # Add meta for fees
                }
                filtered.append(item)
                
            return {"status": "ok", "data": filtered}
        except Exception as e:
            return {"status": "error", "message": str(e)}
    return {"status": "error", "message": "Not initialized"}

@app.post("/api/journal/sync")
async def sync_journal(request: Request):
    """증권사 서버와 매매내역 동기화 (누락 데이터 복구)"""
    data = await request.json()
    if engine_instance:
        try:
            count = engine_instance.sync_trade_history(data.get("start"), data.get("end"))
            return {"status": "ok", "count": count}
        except Exception as e:
            return {"status": "error", "message": str(e)}
    return {"status": "error", "message": "Engine not initialized"}

# -- 체크리스트 --

@app.get("/api/checklist")
async def get_checklist():
    """체크리스트 전체 조회"""
    return {"status": "ok", "data": ChecklistDAO.get_all()}

@app.post("/api/checklist")
async def add_checklist(request: Request):
    """체크리스트 항목 추가"""
    data = await request.json()
    item = ChecklistDAO.add_item(data.get("text"))
    return {"status": "ok", "data": item}

@app.post("/api/checklist/update")
async def update_checklist(request: Request):
    """체크리스트 완료 여부 수정"""
    data = await request.json()
    ChecklistDAO.update_status(data.get("id"), data.get("is_done"))
    return {"status": "ok"}

@app.delete("/api/checklist/{item_id}")
async def delete_checklist(item_id: int):
    """체크리스트 삭제"""
    ChecklistDAO.delete_item(item_id)
    return {"status": "ok"}


# ==================================================================================
# [6] 디버그 및 기타 (Debug)
# ==================================================================================




# ==================================================================================
# [7] 서버 시작 (Server Entry Point)
# main.py에서 호출하는 함수
# ==================================================================================

def start_server(engine):
    """웹 서버 실행 함수"""
    global engine_instance, visualization_service
    engine_instance = engine
    visualization_service = TradeVisualizationService(engine)
    
    # 로고 핸들러 등록 (실시간 로그용)
    import logging
    root_logger = logging.getLogger()
    
    # 중복 방지: 이미 핸들러가 있으면 추가 안 함
    if not any(isinstance(h, LogListHandler) for h in root_logger.handlers):
        # 포매터 설정 (원하는 포맷으로 로그가 보이도록)
        formatter = logging.Formatter("[%(levelname)s] %(message)s")
        list_handler.setFormatter(formatter)
        root_logger.addHandler(list_handler)
        logger.info("LogListHandler registered to root logger.")

    import uvicorn
    # 접속 로그(access log)는 끄고 에러만 출력 (콘솔 도배 방지)
    config = uvicorn.Config(app, host="0.0.0.0", port=8000, log_level="warning", access_log=False)
    server = uvicorn.Server(config)
    server.run()
