---
description: 안전하고 체계적인 코드 리팩토링 및 구조 개선 절차 (백업 및 비교 검증 필수)
---

# 코드 리팩토링 표준 절차 (Code Refactoring SOP)

이 워크플로우는 기존 코드의 기능을 100% 보존하면서 구조와 가독성을 개선하기 위한 필수 절차입니다.
리팩토링 요청이 들어오면 **반드시** 아래 단계를 순서대로 수행해야 합니다.

## 0. 사전 필수 작업: Dead Code 정리 (Prerequisite)
효율적인 리팩토링을 위해 **본 작업 시작 전 반드시 `/dead_code_analysis` 워크플로우를 먼저 수행**해야 합니다.
- **목적:** 사용되지 않는 코드를 리팩토링하는 시간 낭비를 방지하고, 코드 분석의 정확도를 높입니다.
- **절차:** `/dead_code_analysis` 실행 -> 미사용 코드 식별 및 삭제 -> 본 리팩토링 워크플로우(Step 1) 진행.

## 1. 연관 소스 및 의존성 분석 (Dependency Analysis)
코드를 수정하기 전에, 해당 파일이 시스템 전체에서 어떤 역할을 하는지 파악하십시오.
- **수신처 확인:** 이 파일을 누가 호출(Import/Call)하는가? (`grep_search` 사용)
- **발신처 확인:** 이 파일이 누구를 호출(Delegation)하는가? (특히 `Engine`, `DAO`, `Manager` 등 핵심 모듈과의 연결)
- **데이터 흐름:** DB 저장, 메모리 갱신, 외부 API 호출 등 "Side Effect"가 발생하는 지점을 식별하여 기록하십시오.

## 2. 안전장치 마련 (Mandatory Backup)
수정을 시작하기 전, 반드시 원본 소스를 백업하십시오.
- **백업 규칙:** 원본 파일명 뒤에 `.bak` 또는 `.original`을 붙여 복사본을 생성합니다.
- **검증 전 삭제 금지:** 리팩토링이 완료되고 사용자의 최종 승인이 떨어지기 전까지는 절대로 백업본을 삭제하지 마십시오.

## 3. 리팩토링 수행 (Refactoring Execution)
분석된 의존성을 유지하며 구조를 개선합니다. 다음은 주요 리팩토링 유형별 가이드라인입니다.

### 3-1. 대형 파일 분리 (File Separation)
비대해진 파일(Monolithic File)을 기능 단위로 분리하여 모듈화합니다.
- **상황 예시:** `app.js`가 1,700줄 이상으로 비대해져 유지보수가 어려움.
- **실행 절차:**
  1. **기능 식별:** 서로 의존성이 적은 논리적 블록을 찾습니다. (예: `Backtest`, `Journal`, `Checklist`)
  2. **파일 생성:** `static/modules/backtest.js`, `static/modules/journal.js` 등으로 분리합니다.
  3. **스코프 관리:** 전역 변수 의존성을 `import/export` 또는 상태 관리 객체로 전환합니다.
  4. **통합 테스트:** 분리 후 `index.html`에서 스크립트 로드 순서를 확인하고, 기능이 원본과 동일하게 동작하는지 검증합니다.

### 3-2. 미사용 코드 제거 (Dead Code Removal)
더 이상 사용되지 않는 레거시 코드를 정리하여 시스템의 순도를 높입니다.
- **상황 예시:** 백엔드 API `/api/tps`가 삭제되었으나, 프론트엔드에 폴링(`setInterval`) 로직이 남아 에러 유발.
- **실행 절차:**
  1. **의존성 검색:** `grep_search`로 해당 함수나 변수를 호출하는 모든 지점을 찾습니다.
  2. **안전한 제거:** 로직을 주석 처리(`//`) 후 에러 발생 여부를 모니터링합니다.
  3. **완전 삭제:** 이상이 없으면 해당 블록과 연관된 스타일(CSS)까지 깔끔하게 제거합니다. "좀비 코드"를 남기지 마십시오.

### 3-3. 중복 로직 통합 (Logic Consolidation)
여러 곳에 흩어진 유사 로직을 하나의 함수나 모듈로 통합합니다.
- **상황 예시:** `watchlist.js`와 `chart.js`에서 동일한 날짜 포맷팅 함수를 각각 구현하여 사용 중.
- **실행 절차:**
  1. **공통화:** `utils/formatters.js`를 만들고 `formatDate()` 함수를 정의합니다.
  2. **치환:** 기존 코드를 공통 함수 호출로 변경합니다.
  3. **검증:** 두 파일 모두에서 날짜가 정상적으로 출력되는지 확인합니다.

### ⚠ 주의사항 (Critical Rules)
- **기능 변경 금지:** 리팩토링은 "코드 정리"이지 "버그 수정"이나 "기능 추가"가 아닙니다. 로직(Logic)을 바꾸지 마십시오.
- **주석 유지/보강:** 기존의 주석을 보존하거나, 더 명확한 한글 주석으로 보강하십시오.

## 4. 시뮬레이션 비교 검증 (Comparative Verification)
단순히 "에러가 안 난다"는 것으로는 불충분합니다. 원본과 리팩토링본의 동작을 비교하여 증명하십시오.
1.  **시나리오 작성:** 리팩토링된 모듈이 수행해야 할 핵심 기능(예: 리스트 저장, 주문 전송 등)을 정의합니다.
2.  **테스트 스크립트:** 가능하다면 `tests/` 폴더에 검증 스크립트를 작성하여 두 버전의 결과를 비교하십시오.
3.  **로그 비교:** 동일한 입력에 대해 원본과 리팩토링본이 동일한 로그/결과를 배출하는지 확인하십시오.

## 5. 최종 보고 및 승인 (Final Review & Approval)
사용자에게 다음 항목을 포함하여 한글로 보고하십시오.
- 변경된 구조의 이점 (가독성 등)
- 보존된 핵심 로직 (DB 저장 흐름 등 확인)
- **비교 테스트 결과:** "원본과 동일하게 작동함"을 입증하는 증거
- 백업 파일 위치 (`server.py.original` 등)

사용자의 명시적 승인이 있을 때만 백업 파일을 삭제하거나 작업을 종료하십시오.