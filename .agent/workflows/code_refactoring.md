---
description: 안전하고 체계적인 코드 리팩토링 및 구조 개선 절차 (백업 및 비교 검증 필수)
---

# 코드 리팩토링 표준 절차 (Code Refactoring SOP)

이 워크플로우는 기존 코드의 기능을 100% 보존하면서 구조와 가독성을 개선하기 위한 필수 절차입니다.
리팩토링 요청이 들어오면 **반드시** 아래 단계를 순서대로 수행해야 합니다.

## 1. 연관 소스 및 의존성 분석 (Dependency Analysis)
코드를 수정하기 전에, 해당 파일이 시스템 전체에서 어떤 역할을 하는지 파악하십시오.
- **수신처 확인:** 이 파일을 누가 호출(Import/Call)하는가? (`grep_search` 사용)
- **발신처 확인:** 이 파일이 누구를 호출(Delegation)하는가? (특히 `Engine`, `DAO`, `Manager` 등 핵심 모듈과의 연결)
- **데이터 흐름:** DB 저장, 메모리 갱신, 외부 API 호출 등 "Side Effect"가 발생하는 지점을 식별하여 기록하십시오.

## 2. 안전장치 마련 (Mandatory Backup)
수정을 시작하기 전, 반드시 원본 소스를 백업하십시오.
- **백업 규칙:** 원본 파일명 뒤에 `.bak` 또는 `.original`을 붙여 복사본을 생성합니다.
- **검증 전 삭제 금지:** 리팩토링이 완료되고 사용자의 최종 승인이 떨어지기 전까지는 절대로 백업본을 삭제하지 마십시오.

## 3. 리팩토링 수행 (Refactoring Execution)
- 분석된 의존성을 유지하며 구조를 개선합니다.
- **기능 변경 금지:** 리팩토링은 "코드 정리"이지 "버그 수정"이나 "기능 추가"가 아닙니다. 로직(Logic)을 바꾸지 마십시오.
- **주석 유지/보강:** 기존의 주석을 보존하거나, 더 명확한 한글 주석으로 보강하십시오.

## 4. 시뮬레이션 비교 검증 (Comparative Verification)
단순히 "에러가 안 난다"는 것으로는 불충분합니다. 원본과 리팩토링본의 동작을 비교하여 증명하십시오.
1.  **시나리오 작성:** 리팩토링된 모듈이 수행해야 할 핵심 기능(예: 리스트 저장, 주문 전송 등)을 정의합니다.
2.  **테스트 스크립트:** 가능하다면 `tests/` 폴더에 검증 스크립트를 작성하여 두 버전의 결과를 비교하십시오.
3.  **로그 비교:** 동일한 입력에 대해 원본과 리팩토링본이 동일한 로그/결과를 배출하는지 확인하십시오.

## 5. 최종 보고 및 승인 (Final Review & Approval)
사용자에게 다음 항목을 포함하여 보고하십시오.
- 변경된 구조의 이점 (가독성 등)
- 보존된 핵심 로직 (DB 저장 흐름 등 확인)
- **비교 테스 결과:** "원본과 동일하게 작동함"을 입증하는 증거
- 백업 파일 위치 (`server.py.original` 등)

사용자의 명시적 승인이 있을 때만 백업 파일을 삭제하거나 작업을 종료하십시오.
